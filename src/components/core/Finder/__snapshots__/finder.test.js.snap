// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Component: Finder should render and call onChange function 1`] = `
<div
  class="finder"
>
  <input
    autocomplete="nope"
    placeholder="Start typing to filter by user..."
  />
</div>
`;

exports[`Component: Finder should render with matched icon 1`] = `
<div
  class="finder"
>
  <input
    autocomplete="nope"
    placeholder="Start typing to filter by user..."
  />
  <img
    alt="check"
    src="function svgrLoader(source) {
  const callback = this.async();

  const _ref = (0, _loaderUtils.getOptions)(this) || {},
        {
    babel = true
  } = _ref,
        options = _objectWithoutPropertiesLoose(_ref, [\\"babel\\"]);

  const readSvg = () => new Promise((resolve, reject) => {
    this.fs.readFile(this.resourcePath, (err, result) => {
      if (err) reject(err);
      resolve(result);
    });
  });

  const previousExport = (() => {
    if (source.toString('utf-8').startsWith('export ')) {
      return source;
    }

    const exportMatches = source.toString('utf-8').match(/^module.exports\\\\s*=\\\\s*(.*)/);
    return exportMatches ? \`export default \${exportMatches[1]}\` : null;
  })();

  const tranformSvg = svg => (0, _core2.default)(svg, options, {
    caller: {
      name: '@svgr/webpack',
      previousExport,
      defaultPlugins: [_pluginSvgo.default, _pluginJsx.default]
    },
    filePath: this.resourcePath
  }).then(jsCode => {
    if (!babel) return jsCode;
    return (0, _core.transformAsync)(jsCode, babelOptions).then(({
      code
    }) => code);
  }).then(result => callback(null, result)).catch(err => callback(err));

  if (previousExport) {
    readSvg().then(tranformSvg);
  } else {
    tranformSvg(source);
  }
}"
  />
</div>
`;

exports[`Component: Finder should render with search icon and call onChange function 1`] = `
<div
  class="finder"
>
  <input
    autocomplete="nope"
    placeholder="Start typing to filter by user..."
  />
  <img
    alt="address"
    src="function svgrLoader(source) {
  const callback = this.async();

  const _ref = (0, _loaderUtils.getOptions)(this) || {},
        {
    babel = true
  } = _ref,
        options = _objectWithoutPropertiesLoose(_ref, [\\"babel\\"]);

  const readSvg = () => new Promise((resolve, reject) => {
    this.fs.readFile(this.resourcePath, (err, result) => {
      if (err) reject(err);
      resolve(result);
    });
  });

  const previousExport = (() => {
    if (source.toString('utf-8').startsWith('export ')) {
      return source;
    }

    const exportMatches = source.toString('utf-8').match(/^module.exports\\\\s*=\\\\s*(.*)/);
    return exportMatches ? \`export default \${exportMatches[1]}\` : null;
  })();

  const tranformSvg = svg => (0, _core2.default)(svg, options, {
    caller: {
      name: '@svgr/webpack',
      previousExport,
      defaultPlugins: [_pluginSvgo.default, _pluginJsx.default]
    },
    filePath: this.resourcePath
  }).then(jsCode => {
    if (!babel) return jsCode;
    return (0, _core.transformAsync)(jsCode, babelOptions).then(({
      code
    }) => code);
  }).then(result => callback(null, result)).catch(err => callback(err));

  if (previousExport) {
    readSvg().then(tranformSvg);
  } else {
    tranformSvg(source);
  }
}"
  />
</div>
`;
